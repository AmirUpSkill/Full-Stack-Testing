package com.amir.testing.service;

import com.amir.testing.dto.CreateTodoDto;
import com.amir.testing.dto.TodoDto;
import com.amir.testing.dto.UpdateTodoDto;
import com.amir.testing.entity.Todo;
import com.amir.testing.exception.ResourceNotFoundException;
import com.amir.testing.repository.TodoRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Implementation of the TodoService interface.
 * Handles the business logic for Todo operations.
 */
@Service // Marks this class as a Spring service component
@RequiredArgsConstructor // Lombok: generates constructor for final fields (dependency injection)
@Slf4j // Optional: Lombok annotation to add a logger instance (log)
@Transactional(readOnly = true) // Default transaction settings for read operations
public class TodoServiceImpl implements TodoService {

    private final TodoRepository todoRepository; // Injected via constructor by Lombok

    /**
     * Creates a new Todo item.
     * Write operations should be marked explicitly as transactional.
     *
     * @param createTodoDto DTO containing the description for the new Todo.
     * @return TodoDto representing the newly created Todo item.
     */
    @Override
    @Transactional // Override default readOnly = true for write operation
    public TodoDto createTodo(CreateTodoDto createTodoDto) {
        log.info("Creating new Todo with description: '{}'", createTodoDto.getDescription());
        Todo todo = new Todo();
        todo.setDescription(createTodoDto.getDescription());
        // 'completed' defaults to false in entity
        // 'id' is generated by JPA on save

        Todo savedTodo = todoRepository.save(todo);
        log.info("Successfully created Todo with ID: {}", savedTodo.getId());
        return mapEntityToDto(savedTodo);
    }

    /**
     * Retrieves all existing Todo items.
     * Inherits class-level @Transactional(readOnly = true).
     *
     * @return A list of TodoDto objects representing all Todos.
     */
    @Override
    public List<TodoDto> getAllTodos() {
        log.info("Retrieving all Todos");
        List<Todo> todos = todoRepository.findAll();
        log.debug("Found {} Todos in database", todos.size()); // Debug level for more detail
        return todos.stream()
                .map(this::mapEntityToDto) // Use the private helper method for mapping
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a single Todo item by its unique identifier.
     * Inherits class-level @Transactional(readOnly = true).
     *
     * @param id The UUID of the Todo item to retrieve.
     * @return TodoDto representing the found Todo item.
     * @throws ResourceNotFoundException if no Todo with the given ID exists.
     */
    @Override
    public TodoDto getTodoById(UUID id) {
        log.info("Retrieving Todo with ID: {}", id);
        Todo todo = findTodoEntityById(id); // Use helper to find or throw
        return mapEntityToDto(todo);
    }

    /**
     * Updates an existing Todo item partially based on the provided data.
     * Write operations should be marked explicitly as transactional.
     * Validation for blank description (if provided) is handled here.
     *
     * @param id            The UUID of the Todo item to update.
     * @param updateTodoDto DTO containing the fields to update (description and/or completed status).
     * @return TodoDto representing the updated Todo item.
     * @throws ResourceNotFoundException if no Todo with the given ID exists.
     */
    @Override
    @Transactional // Override default readOnly = true for write operation
    public TodoDto updateTodo(UUID id, UpdateTodoDto updateTodoDto) {
        log.info("Attempting to update Todo with ID: {}", id);
        Todo existingTodo = findTodoEntityById(id); // Find existing or throw

        boolean updated = false; // Track if any changes were made

        // --- Corrected Description Update Logic ---
        // 1. Check if description was provided AT ALL
        if (updateTodoDto.getDescription() != null) {
            // 2. IF provided, THEN check if it's blank
            if (updateTodoDto.getDescription().isBlank()) {
                // It was provided but it's blank - log and ignore (don't update)
                 log.warn("Update request for Todo ID {} provided a blank description. Ignoring.", id);
            } else {
                // It was provided AND it's not blank - Update it
                log.debug("Updating description for Todo ID: {}", id);
                existingTodo.setDescription(updateTodoDto.getDescription().trim()); // Trim whitespace
                updated = true;
            }
        }
        // If updateTodoDto.getDescription() was null, we do nothing with the description.
        // --- End Corrected Description Update Logic ---


        // Update completed status only if explicitly provided (not null)
        if (updateTodoDto.getCompleted() != null) {
            log.debug("Updating completed status for Todo ID: {} to {}", id, updateTodoDto.getCompleted());
            existingTodo.setCompleted(updateTodoDto.getCompleted());
            updated = true;
        }

        if (updated) {
            Todo savedTodo = todoRepository.save(existingTodo); // Persist changes
            log.info("Successfully updated Todo with ID: {}", id);
            return mapEntityToDto(savedTodo);
        } else {
            log.info("No update required for Todo with ID: {} (no relevant fields provided or data invalid)", id);
            // Return the existing state if no changes were applied
            return mapEntityToDto(existingTodo);
        }
    }

    /**
     * Deletes a Todo item by its unique identifier.
     * Write operations should be marked explicitly as transactional.
     *
     * @param id The UUID of the Todo item to delete.
     * @throws ResourceNotFoundException if no Todo with the given ID exists.
     */
    @Override
    @Transactional // Override default readOnly = true for write operation
    public void deleteTodoById(UUID id) {
        log.info("Attempting to delete Todo with ID: {}", id);
        // Check existence before attempting deletion to ensure the exception is thrown if not found
        if (!todoRepository.existsById(id)) {
            log.warn("Delete failed: Todo not found with ID: {}", id);
            throw new ResourceNotFoundException("Cannot delete. Todo not found with id: " + id);
        }
        todoRepository.deleteById(id);
        log.info("Successfully deleted Todo with ID: {}", id);
    }

    // --- Helper Methods ---

    /**
     * Finds a Todo entity by its ID or throws ResourceNotFoundException.
     * Centralizes the logic for retrieving an entity that is expected to exist.
     *
     * @param id The UUID of the Todo to find.
     * @return The found Todo entity.
     * @throws ResourceNotFoundException if the Todo is not found.
     */
    private Todo findTodoEntityById(UUID id) {
        return todoRepository.findById(id)
                .orElseThrow(() -> {
                    log.warn("Todo not found with ID: {}", id);
                    return new ResourceNotFoundException("Todo not found with id: " + id);
                });
    }

    /**
     * Maps a Todo entity object to a TodoDto object.
     *
     * @param todo The Todo entity to map.
     * @return The corresponding TodoDto.
     */
    private TodoDto mapEntityToDto(Todo todo) {
        // Using the AllArgsConstructor from Lombok on TodoDto is convenient here
        return new TodoDto(
                todo.getId(),
                todo.getDescription(),
                todo.isCompleted() // Use isCompleted() getter for boolean field
        );
    }
}